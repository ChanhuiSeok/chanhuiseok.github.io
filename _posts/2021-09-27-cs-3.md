---
title: "[운영체제] 한번에 모아보는 면접대비 운영체제 질문 목록들"
date: 2021-09-27 21:00:00 +0900
categories: [1.Studying, Computer Science]
tags: [운영체제, OS]
seo:
  date_modified: 2021-09-27 21:01:50 +0900
---

면접 전공 지식을 준비하시는 분들을 위해, 운영체제 파트에서 나올만한 문항들을 핵심만 간추려서 정리해 보았습니다.

컴퓨터구조 과목에 포함되는 문항들도 일부 있습니다.

원하시는 키워드를 ctrl + F로 검색해 보세요!

(간추려서 정리한 것이라서 상세한 개념 설명이 부족할 수 있습니다. 각 문항 중 중요한 개념은 다른 운영체제 게시물처럼 별도의 주제로 다뤄서 작성할 예정입니다.)

---

## Q. 임계영역이 무엇인가요? 임계영역이 만족해야 하는 조건이 있나요?
> 키워드 : 임계영역, 크리티컬 섹션, 임계 자원

* 임계 자원 : 여러 프로스세가 동시에 공유해서 사용하면 안 되는 자원
* 임계 영역 : 임계 자원에 접근하고 실행하는 프로그램의 코드 부분. `크리티컬 섹션`이라고도 한다.

* 임계 영역이 문제가 발생하지 않도록 만족해야 하는 조건
  * `상호 배제(Mutual exclution)` |
하나의 프로세스가 임계 영역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다.

  * `진행(Progress)` |
임계 영역에 들어간 프로세스가 없는 상태에서, 들어가려 하는 프로세스가 여러개라면 어느 것이 들어갈지 결정해주어야 한다.

  * `한정 대기(Bounded waiting)` |
다른 프로세스의 기아(Starvation)을 방지하기 위해, 한 번 임계 구역에 들어간 프로세스는 다음 번 임계 영역에 들어갈 때 제한을 두어야 한다.

> 레퍼런스 : https://ko.wikipedia.org/wiki/%EC%9E%84%EA%B3%84_%EA%B5%AC%EC%97%AD_%EB%AC%B8%EC%A0%9C

---

## Q. race condition이 무엇인가요?
> 키워드 : 레이스 컨디션, 임계 영역, 뮤텍스, mutex lock

두 개 이상의 작업이 동기화 처리 장치 없이, 임계 자원을 서로 사용하려고 접근하는 상황입니다. 즉, 자원을 두고 경쟁한다는 의미에서 race condition 이라는 용어가 나오게 되었습니다.

코드에서 이러한 문제가 발생할 수 있는 부분을 critical section(임계 영역)이라고 하며, 이 race condition 을 해결하기 위해서 한 번의 하나의 스레드만 임계 영역에 진입할 수 있도록 제어하는 기법을 `mutex lock` 이라고 합니다.

---

## Q. Mutex lock 기법의 동작 방식을 간단히 말하자면?

하나의 프로세스가 key를 가지고 임계 영역에 들어가서 lock을 걸면, 그 키를 가지고 있지 않은 다른 프로세스들은 임계 영역에 들어가지 못하고 기다리게 됩니다.

실행 중인 프로세스가 모두 처리 후 키를 반환하면, 그 때 대기하던 프로세스 중 하나가 들어갈 수 있습니다.

---

## Q. 프로세스를 설명해 주세요.

* 프로세스 : 컴퓨터에서 실행 중인 프로그램이라고 할 수 있습니다. 독립적인 메모리 영역을 가지며 스택, 힙, 데이터, 코드라는 구조를 가집니다.

  * 스택 : 데이터를 일시적으로 저장하는 영역. 지역변수나 함수의 반환 주소, 매개 변수 등을 저장
  * 힙 : 동적 메모리 할당에 쓰이는 곳
  * 데이터 : 이 영역은 전역 변수를 저장하고, 프로그램 가상 주소 공간이 됨
  * 코드 : 프로그램 영역으로, 컴파일한 프로그램이 저장됨

---

## Q. 캐시가 무엇인가요? (컴퓨터구조)

자주 쓰는 데이터를 원래 저장된 곳보다 속도가 더 빠른 임시 저장소(캐시)에 저장해서, 데이터를 빠르게 읽어올 수 있게끔 하는 것이 캐시입니다. 전체적인 처리 성능을 높일 수 있게 됩니다.

컴퓨터 시스템에서는 **캐시 메모리**를 예시로 들 수 있습니다. 프로세서, 즉 CPU와 메인메모리의 처리 속도는 차이가 현저하게 나기 때문에 매번 메모리 데이터를 읽어오려고 한다면 속도가 느려서 오버헤드가 커지게 됩니다. 

그래서 자주 쓰는 데이터를 메인메모리보다 더 빠른 **캐시 메모리**에 두어서, 더 빨리 읽어올 수 있게끔 합니다.

---

## Q. 캐시 Hit Rate를 높이기 위해 사용하는 지역성(Locality) 원리 2가지는?

캐시가 효율적으로 작동하려면 캐시에 저장되는 데이터들이 지역성을 가져야 하는데, 공간적 지역성과 시간적 지역성으로 나눌 수 있습니다.

* 공간적 지역성은, 대부분 프로그램은 참조한 주소와 **인접한 주소의 내용**을 다시 한 번 참조하는 특성이 있다는 것입니다.

* 시간적 지역성은, **한 번 참조한 주소를 다시 한 번 재참조**하는 특성이 있다는 것입니다.

---

## Q. 인터럽트가 무엇입니까? 왜 사용합니까? 인터럽트 발생 시 수행 과정을 간략히 말해 보세요. (인터럽트 서비스 루틴)

인터럽트는 끼어들다 정도의 표현이 담긴 단어입니다. 즉, 현재 실행 중인 프로그램을 중단하고, 다른 프로그램의 실행을 요구하는 명령어입니다.

키보드를 누름으로 인해 발생하는 인터럽트나, 입출력 장치등에 의한 인터럽트등이 있고, 소프트웨어적인 인터럽트는 시스템 콜(system call)로써 구현이 됩니다. 

인터럽트가 발생하면, 현재 실행 중이었던 프로세스의 상태 정보를 PCB에 저장해 둡니다. 이후 인터럽트 서비스 루틴이 인터럽트를 처리하고, 처리가 모두 끝나면 다시 이전 작업 상태 정보를 복구하여 재개합니다.

---

## Q. 시스템 콜(system call)이 무엇인가요?

응용프로그램에서 **시스템 커널에 어떠한 기능을 수행해 달라고** 요청하는 것을 말합니다. **사용자가 직접 커널에 접근할 수는 없기 때문에**, 이를 **시스템 콜을 통해 대신**하는 것입니다.

리눅스의 프로세스 정지 명령어나 fork 명령어, 파일을 오픈, 클로즈 하거나 읽는 등 open, read, close 등의 명령들도 모두 시스템 콜에 해당이 됩니다.

---

## Q. 모놀리식 커널 구조와 마이크로 커널 구조를 비교해 주세요.

모놀리식의 경우 **커널에 운영체제의 모든 기능을 구현해 놓은 것**을 말합니다. 직접 통신이 가능해 시스템 자원을 효율적으로 사용할 수는 있지만, 단점으로는 커널의 크기가 너무 커지고, 이에 따라 버그나 오류를 잡기 힘들어지며, 유지 보수도 어려워집니다. 동일한 메모리의 커널에서 모두 실행되는 바람에 한 부분에서 문제가 발생하면 시스템 전체에 심각한 오류를 일으킬 수도 있습니다.

반면 **마이크로 커널 구조는 이름에서도 나와 있듯이 커널의 기능을 많이 축소시켜서 최소한의 기능들만 포함시키고, 나머지는 사용자 영역에서 수행하도록 하는 것입니다.** 이렇게 되면 모듈화 정도가 높아져서 확장성이나 이식성, 규모 확장성 등이 높아지지만, 각 모듈강 통신이 빈번히 발생해 성능이 떨어질 수도 있습니다.

---

## Q. 프로세스의 상태변화에 대해 말씀해 주세요.

프로세스가 가질 수 있는 상태를 말하자면, 생성 단계 → (레디 → 러닝 → 웨이트) → 종료 로 말할 수 있습니다. 레디 큐에 있던 프로세스가 **디스패쳐에 의해 CPU를 할당받게 되면** 그 프로그램은 실행을 시작하게 됩니다. 이것은 실행 큐에 담깁니다.

**만약 입출력 작업이나 Event 등이 발생하게 되면 실행 큐에서 실행 중이던 프로세스는 wait 큐로 이동**합니다. 작업이 모두 끝나면 다시 레디 큐로 가서 할당받기를 대기하게 됩니다

인터럽트가 발생한다면, 실행 큐에 있던 프로세스는 레디 큐로 가게 됩니다.

---

## Q. PCB가 무엇입니까?, 문맥 교환(Context-switching)이란 무엇인가요?

PCB는 프로세스의 각종 상태 정보들을 저장해 두는 곳입니다. 특히 PCB에서는 Program counter라고 해서 다음 명령어의 주소를 가지고 있기도 합니다.

문맥 교환은, 인터럽트나 시스템 콜 등으로 현재 실행 중인 프로세스의 제어를 다른 프로세스에 넘겨서 그 프로세스가 실행 가능하도록 하는 것을 말합니다. 즉, 실행권을 다른 곳에 넘기는 과정입니다. 프로세서의 레지스터에 있던 내용은 나중에 다시 사용할 수 있도록 PCB에 저장됩니다.

이렇게 PCB의 이전 상태를 저장하는 등, 컨텍스트 스위칭 동안에는 CPU가 일을 하지 못하기 때문에 이것이 자주 일어난다면 **성능 저하를 유발**할 수 있습니다.

쓰레드의 경우는 문맥 교환에 있어서 프로세스보다는 좋은 성능을 낼 수 있습니다. 이미 쓰레드 자체가 **프로세스 내의 대부분을 공유**하고 있기 때문입니다. 따라서 이전 상태값을 전부 저장하거나 할 필요가 없어지고, 문맥 교환에 따른 성능 저하가 줄어들 수 있습니다.

---

## Q. 비선점 스케줄링 알고리즘 2가지를 말씀해 주세요.

`FCFS`, `SJF(Shortest Job First)`가 있고, 만약 SJF에 선점을 더하면 `SRTF(Shortest Remaining Time first)`가 됩니다.

`FCFS`는 FIFO와 그 개념이 동일합니다.

---

## Q. 스케줄링 기법에서, Aging 이란 무엇입니까?

레디 큐에서 프로세스가 너무 오랫동안 기다리지 않도록, **시간이 지날수록 우선순위를 높여주는 방식**을 말합니다.

---

## Q. 멀티레벨 큐와 멀티레벨 피드백 큐 알고리즘에 대해 말씀해 주세요.

멀티레벨 큐 방식은 레디 큐를 여러 개로 분할해서, 분할된 큐들의 우선순위를 서로 다르게 하는 것을 말합니다. 한 번 큐에 배정되면, 다른 큐로 이동이 불가합니다. 하위에 있는 큐의 프로세스는 모든 상위 프로세스가 대기중이지 않았을 때만 실행이 가능합니다.

그러나 멀티레벨 피드백 큐의 경우, **한 번 큐에 배정된 것이라도 cpu busrt time에 따라 큐 간 이동을 할 수 있는 특징**을 가집니다. 각 큐는 특정한 time quantum 을 가지는데, 그 안에 작업을 모두 처리하지 못하면 하위큐로 이동하게 됩니다.

---

## Q. 페이징 기법이 무엇인가요? (메모리 관리기법)

프로세스를 페이지 단위로 나누고, 메모리도 물리적인 frame 단위로 나누어서 관리하는 기법을 말합니다. 비연속 메모리 할당 기법의 대표적인 예시입니다.

연속적으로 메모리를 할당할 경우, `외부 단편화`라는 문제가 발생할 수 있습니다. 이것은 메모리에 남은 공간들은 있으나, 그 빈 공간이 마치 Hole처럼 흩어진 형태로 존재해서, 홀의 크기보다 더 큰 프로세스는 아무리 빈 공간이 있더라도 메모리에 적재될 수 없는 현상을 말합니다.

그래서 페이징 기법을 통해 페이지 단위로 나뉜 프로세스를 프레임에 적재하면, `외부 단편화` 문제는 해결되게 됩니다. 그러나 프레임 자체 안에 공간이 발생하게 되는 **내부 단편화 문제**가 발생할 수 있습니다.

(하지만 외부 단편화 문제를 해결하는 것이 성능에 더 이점이 있습니다.)

---

## Q. 세그멘테이션이란 무엇인가요?

페이징 기법이 물리적으로 크기가 고정된 page, frame 단위로 메모리를 나누었다면, 세그멘테이션은 프로세스를 **크기가 동적으로 변할 수 있는 단위인 세그먼트**로 나누는 것입니다.

세그먼트는 프로그램을 구성하는 서브 루틴, 프로시저, 함수나 모듈 등으로 구성됩니다. **즉, 각 세그먼트는 연관된 기능을 수행하는 하나의 모듈 프로그램으로 이해할 수 있습니다.**

그러나 세그멘테이션 방식은 세그먼트들을 단위로 해서 메모리에 적재하다 보니, 외부단편화가 발생할 수 있습니다.

---

## Q. 가상 메모리(virtual memory)가 등장하게 된 이유는 무엇인가요?

메인 메모리의 용량은 한정적입니다. 가령 물리 메모리 크기가 100메가 바이트였는데, 500메가 바이트가 필요한 프로세스가 있다면, 이는 컴퓨터에서 실행할 수 없을 것입니다. 이러한 문제를 해결하기 위해서 가상 메모리 개념이 등장합니다.

즉, 프로세스의 모든 부분은 항상 필요한 것이 아니라서, 현재 실행에 **필요한 부분만을 메모리에 올림으로써** 해결하는 것입니다. 그리고 이러한 부분 단위는 페이지 단위가 일반적이기 때문에 이를 두고 **요구 페이징 기법**이라고도 부릅니다.

**필요한 프로그램만 페이지 단위로 메인 메모리에 적재**하는데. 페이지 테이블의 각 항목에 valid bit를 두며, 이것이 1일 경우 메모리에 그 페이지가 있다는 뜻이고, 0일 경우 메모리에 없다는 의미가 됩니다.

이 때, 프로그램이 메모리에 적재되지 않은 페이지를 사용하려고 한다면 이를 두고 **page fault(페이지 폴트)** 라고 부릅니다.

